#include <ros/ros.h>
#include <map>
#include <sensor_msgs/LaserScan.h>
#include <std_msgs/Bool.h>
#include <std_msgs/Float64MultiArray.h>

sensor_msgs::LaserScan scan_msg;
std_msgs::Bool detect_msg;
std_msgs::Bool avoid_function_msg;
std_msgs::Float64MultiArray avoid_heading_angle_msg;
std_msgs::Float64MultiArray object_distance_msg;
ros::Time detection_start_time;

int INDEX;
int size;
int detect_count;
int object_right_angle_index;
double object_right_angle;
int object_left_angle_index;
double object_left_angle;

double object_right_distance;
double object_left_distance;
int dummy;
std::vector<int> find_gap;
std::vector<int> consecutiveLengths;

ros::Publisher detect_pub;
ros::Publisher avoid_heading_angle_pub;
ros::Publisher avoid_function_start_pub;
ros::Publisher object_distance_pub;

bool checkConsecutiveGroups(const std::vector<int>& nums, std::vector<int>& consecutiveLengths) {
    if (nums.empty()) {
        return false;
    }

    consecutiveLengths.clear();
    int currentLength = 0;

    for (size_t i = 0; i < nums.size(); ++i) {
        if (nums[i] == nums[i - 1] + 1) {
            currentLength++;
        } else {
            consecutiveLengths.push_back(currentLength);
            currentLength = 0;
        }
    }

    consecutiveLengths.push_back(currentLength);

    return true;
}

long map(long x, long in_min, long in_max,long out_min, long out_max)
{
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  
}

void scan_Callback(const sensor_msgs::LaserScan::ConstPtr& msg){
    

    for(int i = -330; i <= 330; i++){
        size = msg->ranges.size();
        INDEX = i + size/2;

        // object_detect
        if(msg->ranges[INDEX] <= 2.3) {
            if(detect_count == 0) { 
                object_right_angle_index = INDEX;
                object_right_distance = msg->ranges[INDEX]; 

            }
            else if (detect_count != 0) { 
                object_left_angle_index = INDEX;
                object_left_distance = msg->ranges[INDEX]; 
            }
            detect_count ++;
        }
        // find gap
        else if( msg->ranges[INDEX] > 2.3 ) {

            find_gap.push_back(INDEX);
        }


        if(detect_count >= 1) {
            detect_msg.data = true;
            detect_pub.publish(detect_msg);
        }
        else {
            detect_msg.data = false;
            detect_pub.publish(detect_msg);
        }

    }
    
    //ROS_INFO("detect_count : %d", detect_count);
    ROS_INFO("detect_msg : %d", detect_msg.data);
    //ROS_INFO("range : %f", msg->ranges[INDEX]);
/*
    if (checkConsecutiveGroups(find_gap, consecutiveLengths)) {
        for (int length : consecutiveLengths) {
            if(!length) {dummy = length;}
            else if(length > dummy) { dummy = length; }
            ROS_INFO("Consecutive group length: %d", length);
        }
    } 
    else {
        ROS_WARN("Input vector is empty.");
    }
    ROS_INFO("dummy: %d", dummy);
*/

    // avoid_function
    if( detect_msg.data == true && detection_start_time.isZero() ) { detection_start_time = ros::Time::now(); }
    if( detect_msg.data == false ) { detection_start_time = ros::Time(0); }

    if(detect_msg.data && (ros::Time::now() - detection_start_time).toSec() >= 0.1 ) {
            
        avoid_function_msg.data = true;
        avoid_function_start_pub.publish(avoid_function_msg);
    }
    else if(!detect_msg.data || (ros::Time::now() - detection_start_time).toSec() <= 0.1 ) { 
         
       avoid_function_msg.data = false; 
       avoid_function_start_pub.publish(avoid_function_msg);
    }

    // avoid angle calculate
    object_right_angle = map(object_right_angle_index, 0, size-1, 0, 360) - 180;
    object_left_angle = map(object_left_angle_index, 0, size-1, 0, 360) - 180;

    avoid_heading_angle_msg.data[0] = object_right_angle; // [0]
    avoid_heading_angle_msg.data[1] = object_left_angle;  // [1]
    avoid_heading_angle_pub.publish(avoid_heading_angle_msg);

    object_distance_msg.data[0] = object_right_distance;
    object_distance_msg.data[1] = object_left_distance; 
    object_distance_pub.publish(object_distance_msg);

    ROS_INFO("object_right_angle : %f", object_right_angle);
    ROS_INFO("object_left_angle : %f", object_left_angle);

    detect_msg.data = false;
    detect_count = 0;
}

int main(int argc, char** argv){
    ros::init(argc, argv, "lidar_detect");
    ros::NodeHandle nh;

    detect_msg.data = false;
    avoid_function_msg.data = false;
    detect_count = 0;
    avoid_heading_angle_msg.data.resize(2);
    object_distance_msg.data.resize(2);

    detect_pub = nh.advertise<std_msgs::Bool>("lidar_object_detect", 1);
    avoid_function_start_pub = nh.advertise<std_msgs::Bool>("avoid_function_start", 10);
    avoid_heading_angle_pub = nh.advertise<std_msgs::Float64MultiArray>("avoid_heading_angle", 10);
    object_distance_pub = nh.advertise<std_msgs::Float64MultiArray>("object_distance", 10);
    ros::Subscriber scan_sub = nh.subscribe("/scan", 10, scan_Callback);

    ros::spin();
    return 0;


}
